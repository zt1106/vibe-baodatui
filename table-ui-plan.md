# Implementing the Poker Table UI (Top-Down View with Responsive Layout)

## 1\. Tech Stack & Codebase Overview

This project is a **React/Next.js** application (using Next 13 App Router) written in TypeScript. We can confirm Next.js usage (e.g. importing Next's navigation and React hooks)[\[1\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L3-L7). The frontend is organized in a monorepo style with shared packages - for example, a @poker/ui-cards library provides card display components[\[2\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/cards/CardRow.stories.tsx#L2-L10). Styling is handled via **CSS Modules** (see the import of a .module.css file in the PlayerAvatar component[\[3\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx#L5-L12)). Storybook is set up for UI components like PlayerAvatar and card rows, indicating a component-driven approach.

**Existing UI components to leverage:** The codebase already includes a PlayerAvatar component (for player name, avatar image, status, etc.) and card display components (CardRow, PlayingCard, etc.). We will reuse these rather than reinventing them. For instance, PlayerAvatar accepts props for name, avatar URL, status, size, and even a custom className for additional styling[\[4\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx#L16-L26) - perfect for our use. Likewise, CardRow from @poker/ui-cards can neatly render a row of playing card components with configurable overlap and angle[\[5\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/cards/CardRow.stories.tsx#L240-L248). The presence of Framer Motion (motion is imported in Storybook[\[2\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/cards/CardRow.stories.tsx#L2-L10)) means we already have an animation library available, though animations are _not_ the primary focus here.

## 2\. Table Design with 3D CSS Transform

We will create a **square table with rounded corners** and a slight 3D tilt to simulate a top-down perspective. This can be achieved entirely with CSS transforms - no 3D library needed (the project maintainer specifically noted that CSS transform is sufficient). The plan:

- **HTML structure:** Introduce a &lt;GameTable&gt; component (likely as a new page at e.g. /game/\[tableId\]/play or a component in the existing page after game starts). It will contain a wrapper div (for positioning context) and the table surface div, plus child elements for avatars, cards, etc. For example:  

- &lt;div className="table-container"&gt;  
    &lt;div className="table-surface" /&gt; {/\* The table top \*/}  
    {players.map(... => &lt;Seat/&gt;)}  
    &lt;/div&gt;
- We might create a &lt;Seat&gt; sub-component for each player seat, containing that player's avatar and card area, to encapsulate positioning logic per seat.
- **CSS for the table:** Style .table-surface to be a square with rounded corners and a felt-like appearance. We can use a fixed aspect ratio of 1:1 to ensure it stays square. For example, .table-surface could use aspect-ratio: 1 / 1; width: 60vmin; max-width: 90%; (so it scales with viewport but not beyond screen) and border-radius: 15% (or a specific pixel radius) to get rounded corners. A green or dark felt color or a subtle radial gradient can be applied as background.
- **3D transform:** To view it "from the top with an angle," we apply a CSS 3D rotation. We'll wrap the table in a container with a perspective, then rotate the table around the X-axis:  

- .table-container { perspective: 800px; }  
    .table-surface {  
    transform: rotateX(30deg); /\* tilt 30° for perspective \*/  
    transform-origin: center center;  
    }
- The perspective on the parent makes the 3D rotation of the table look realistic (the far end appears slightly smaller). We can adjust the angle (20-45° range) to what looks best. The result is the table appears slightly slanted towards the viewer, as if the "camera" is above and facing the table. No additional libraries are needed for this effect - just CSS3. (The project already uses similar CSS techniques for other components; e.g., a radial-gradient background is used in the waiting room UI[\[6\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L324-L332), showing comfort with CSS backgrounds).
- **Layering:** The table should sit _behind_ other elements like avatars and cards. We can ensure .table-surface has a lower stacking context (e.g., a lower z-index) than the player elements, or simply place it earlier in the DOM so that later elements (avatars/cards) render on top. This way, player avatars won't be visually cut off by the table element.

## 3\. Evenly Spacing Player Avatars Around the Table

Next, we place the **player avatars** on the outer sides of the table, evenly distributed for anywhere from 3 up to 7 players. We will leverage the existing &lt;PlayerAvatar&gt; component for each player's avatar and name tag. Here's the approach for positioning them in a circle around the table:

- **Dynamic player data:** The game state already tracks players/seats, so we can use that. In the prepare stage, for example, the state holds an array of players (with userId, nickname, avatar, etc.)[\[7\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L184-L192). We'll likely have a similar list available when the game starts. We can iterate over the players array to render each avatar.
- **Compute positions on a circle:** We treat the center of the table as the origin and place players at equal angle intervals around it. For N players, each seat is separated by 360°/N. For example, if N=4, seats might be at 0°, 90°, 180°, 270° (in a circular arrangement). We can choose where angle 0° starts (e.g. top-center of table or bottom-center) and rotate around. A straightforward choice: angle 0 at the top center of the table, and increase clockwise. In code, for each player index _i_ (0-based):  

- const angle = (2 \* Math.PI \* i) / N; // angle in radians  
    const radius = tableRadius + avatarOffset;  
    // tableRadius could be ~0.5\*tableWidth if avatars sit just outside the table edge  
    const centerX = tableWidth/2, centerY = tableHeight/2;  
    const avatarX = centerX + radius \* Math.sin(angle);  
    const avatarY = centerY - radius \* Math.cos(angle); // using sin/cos with appropriate orientation
- (Note: We use sin for X and cos for Y, with a minus sign, if 0° is at top. Adjust formula depending on chosen 0° reference.) This gives coordinates (avatarX, avatarY) for the center of each avatar.
- **Apply to CSS:** We position avatars absolutely in the .table-container. For each avatar element, set position: absolute; left: avatarXpx; top: avatarYpx;. To center the avatar at that point (since left/top typically position the top-left corner), we can offset by half the avatar's size. A convenient trick: use CSS transform: translate(-50%, -50%) on the avatar element, which will shift it so that the given left/top coordinates refer to its center. The PlayerAvatar component supports a size prop (default 64px) and custom className[\[4\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx#L16-L26) - we can use size to ensure all avatars are uniform and perhaps scale with screen if needed (or simply a fixed pixel size like 80px on desktop).
- **Responsive behavior:** Because the table itself will resize with the viewport (using relative units or max-width), we want avatar positions to update accordingly. Two possible solutions: (a) Recompute positions on window resize in a React effect, updating state that drives the CSS positions; or (b) use purely CSS percentage positioning relative to container size. The JS recalculation approach might be simplest to implement and reason about: attach a resize event or use a ResizeObserver on the table container to recalc avatarX, avatarY for each seat whenever size changes. Given that performance is not a big concern with at most 7 avatars, this is fine. Alternatively, using CSS, one could set positions in percentages (e.g., left: 50% + cosθ \* R% using the calc function). However, CSS cannot directly compute sine/cosine, so we'd have to hardcode percentages for each seat or use a precomputed lookup - not very flexible. So we'll go with computing in JS for accuracy.
- **Even spacing validation:** This method naturally gives equal spacing. For example, with 3 players, they'll form an equilateral triangle around center; with 7, roughly a heptagon. If the game's table capacity is fixed (the code suggests capacity default 6[\[8\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L280-L288)), we might consider using fixed seat angles for those 6 positions and simply not render empty seats. But the requirement "players count would change from 3 to 7" suggests we want to dynamically space **only the actual players**. So if only 3 players are seated, they'll be spaced 120° apart rather than leaving "gaps" for missing seats - this makes the table feel appropriately populated. (We could later extend this to show empty chair placeholders if desired, but it's not required.)
- **Example:** Suppose 5 players. Angle difference = 72°. If 0° is top, player0 at top-middle, player1 ~72° clockwise (upper right), player2 ~144° (lower right), player3 ~216° (lower left), player4 ~288° (upper left). All would be evenly distributed around the table's perimeter.
- **No special animation needed:** We simply place them; since "animation is not important" here, we won't animate these positions. (If we wanted, we could fade or slide them in using Framer Motion, but that's optional fluff.)

## 4\. Player Card Areas on the Table (near each Avatar)

For each player, we also need to designate an area **inside the table** where their cards will be shown. These should be located just in front of the player's avatar, slightly inside the table edge. The approach is similar to avatars, with a slightly smaller radius:

- **Positioning:** We can use the same angle for a player's card area as for their avatar (so that it lines up radially). We choose an inner radius, perhaps around 80-90% of the table's half-width. For example, if avatars sit at radius ~1.1 × (table half-width) (just outside the edge), we might put card areas at 0.8 × (table half-width) (just inside the edge). In implementation, after computing avatarX, avatarY, we could compute cardX, cardY as:  

- const innerRadius = tableRadius \* 0.8;  
    const cardX = centerX + innerRadius \* Math.sin(angle);  
    const cardY = centerY - innerRadius \* Math.cos(angle);
- Then position a card container &lt;div className="card-area"&gt; at (cardX, cardY) similarly with absolute positioning. Again use transform: translate(-50%, -50%) so the coordinate is the center of the card area.
- **Card area content:** Within each card-area div, we can render the actual cards the player holds (once that data is available). The project's CardRow component is ideal for displaying a hand of cards fanned out. We can use &lt;CardRow cards={player.cards} size="md" overlap="65%" angle={0} /&gt; for example - this will render the card images. The CardRow supports an angle prop to curve the row of cards[\[5\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/cards/CardRow.stories.tsx#L240-L248). We might even use this to slightly curve the cards toward the player: for instance, for a player at the top of the table, we might set angle={10} (fan upward), and for a player at bottom, angle={-10} (fan downward), so that the cards subtly face the player. However, a simpler approach is to keep angle={0} (a straight line or very slight curve) for all hands initially. The cards will still overlap nicely (using the overlap prop) and CardRow will handle responsive card sizing (size prop can be sm/md etc.). The card backs/fronts and flip animations are already handled by the PlayingCard and animation provider in the code.
- **Orientation:** We will keep all cards oriented upright to the viewer for simplicity (no rotation of card faces). In a fully realistic view, the cards of players on the far side might appear rotated upside-down relative to us, but since this is a top-down game UI, conventionally **all players' cards are shown from the viewer's perspective** (often only your own cards are face-up anyway, others face-down or minimal). So we don't need to rotate each card area to face its player; just position it near them. This keeps the implementation simple (just drop in a CardRow). If needed, we could adjust the angle or curveVerticalOffset in CardRow to mimic slight curvature aligned with table curve (the CardRow component was built to support curved arrangements[\[9\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/cards/CardRow.stories.tsx#L2-L5), which we can tweak if desired).
- **Responsive position:** Just like avatars, these card areas should move when the table resizes. Using the same calculation method (with inner radius tied to table size) and recalculating on resize ensures they stay correctly placed relative to avatars.
- **Example:** If a player's avatar is at the top edge (0°), their card area might be just below it, inside the table. If an avatar is on the right side, the card area will be to its left, on the table. This way each player's cards appear in front of them on the tabletop.

## 5\. Responsive Scaling and Reflow Behavior

We target desktop usage, but we still need the table UI to **resize and reflow** with the window size (e.g. if the user changes the window or has different screen resolutions). Key considerations for responsiveness:

- **Table scaling:** By using relative units (like vmin, percentages, or CSS clamp), the table will automatically scale with the browser window. For instance, setting the table's width to something like min(80vw, 80vh) (80% of viewport width or height, whichever is smaller) could work to utilize space while ensuring it's not too large for the viewport. The aspect-ratio: 1/1 will maintain it as a square. Using CSS calc or clamp() we can fine-tune the size range. The background and border radius will naturally scale with it.
- **Avatars & cards repositioning:** If we use JS for positions, we'll implement a resize handler. In a React functional component, we can use the useEffect hook to add a 'resize' event listener on window (or use a ResizeObserver on the table container element). On resize, recalc all avatar and card positions and update state that drives their style. Because we're dealing with only a handful of elements, this will be performant. If using CSS for some parts, just ensure container uses relative sizing.
- **Avatar/card size adjustments:** We might choose to slightly scale avatar size or card size based on table size. For example, if the screen is very large, 64px avatars might look small relative to the table - we could use a larger size or a percentage. Since the PlayerAvatar component's size prop can accept a number or string (e.g. "80px" or "10%"), we have flexibility[\[4\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx#L16-L26). We could do something simple like set avatar size to a fraction of table width (maybe via CSS by setting --player-avatar-size using the rootStyle as the component does[\[10\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx#L61-L65)). Similarly, the CardRow component can use different preset sizes (sm, md, lg) - possibly we choose the size based on screen width (maybe md normally, but could go to lg on very large screens). These tweaks will ensure the UI scales nicely rather than being tiny on a big monitor or overflowing on a smaller one.
- **Testing different view sizes:** We should test the layout at various window sizes (since it's desktop-only, we don't worry about extremely small mobile screens, but consider different desktop resolutions or if the user resizes the browser window). The avatars should always remain at the correct relative positions around the table. If using percentages or a well-implemented resize effect, this will be smooth. We also ensure that at the smallest intended size, the table and avatars still fit without overlapping UI (we can set a minimum table size in CSS).
- **Overflow and scaling:** The .table-container can be a flex container or centered div. In the prepare screen code, they used overflow: hidden on the main container[\[6\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L324-L332) to avoid scrollbars; we can do similarly if needed. But if everything is sized by viewport %, it shouldn't overflow.

## 6\. Additional Table-Linked UI Elements

Beyond avatars and player cards, the game table UI may include other elements that need positioning relative to the table. Our design will accommodate these as well:

- **Community cards (flop/turn/river):** In poker, community cards are laid in the center of the table. We can dedicate a central area on the table for these. Since our table is tilted, placing them at dead-center is fine (the perspective won't distort child elements of the rotated table dramatically for small angles). One approach: render community cards using the existing CardRow component as well, but with a shallow curve or no curve (angle 0) and positioned at center. For instance, &lt;CardRow cards={communityCards} size="md" overlap="32%" angle={0} /&gt; absolutely centered on the table-surface could display the flop nicely. We might need to apply an extra transform to match the table's perspective if we want them to lie "flat" on the table, but given the mild tilt, simply overlaying them might be acceptable. If needed, we could wrap the CardRow in a container with a slight rotateX to match the table plane.
- **Pot/Chips:** A pile of chips or pot amount is often shown in the middle of the table. That can be an element centered on the table as well (perhaps slightly down from exact center to indicate it's on the table felt). We can absolutely position a chip stack icon or text at 50%/50% of container. If we want to simulate it on the table surface, we might give it a small translateY offset to appear "down on the table".
- **Dealer button:** If there is a dealer button that moves between players, we can position it near a specific player's avatar. We could use the same coordinate system: e.g., for the dealer's seat index, take their angle and perhaps use a radius in between the avatar radius and card radius (so the dealer button sits on the table edge in front of that player). By computing that similarly or by attaching it to the Seat component for that player (with some offset), it will move automatically when the dealer seat changes (just by changing which seat has the button).
- **Seat grouping:** For maintainability, it may be wise to group avatar + card area (and any seat-specific tokens like dealer button) into a single **Seat component**. This component would accept the player data and seat index, compute positions internally (or accept precomputed positions), and render &lt;PlayerAvatar&gt; and the card area (with possibly &lt;CardRow&gt; if the player's cards are known). This encapsulation means each seat can handle its own absolute positioning and child alignment. The GameTable component then just maps through players/seats and outputs &lt;Seat key={i} .../&gt; for each. Given the code's existing patterns, we could integrate with how seats are represented. For example, in the prepare state they form a seats array mapping seatNumber to player[\[11\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L308-L314). In the game state, we might do similarly.
- **Z-index and stacking context:** We have to ensure that these additional elements appear correctly. Community cards and pot should appear _on top of_ the table (above the table surface but likely below avatars - or at least not covering avatars). They will naturally be above the table if the table's element has a lower z-index. We might give community cards a slightly lower z-index than avatars so that an avatar image at the table edge isn't overlapped by a card. These layering decisions will make the UI look polished.
- **Animations (future consideration):** While not required now, note that the project's animation capabilities (Framer Motion) could be later used for fancy effects - e.g., sliding cards from the deck to players (with motion presets), chip stack growing when a player bets, etc. The architecture we're setting up (with explicit positioning) actually makes those animations feasible: one can animate the absolute positions or transforms of these seat elements. Since the question explicitly de-emphasized animation, we will leave this as a future enhancement.

## 7\. Implementation Plan Summary

Finally, here's a step-by-step breakdown of how to implement this in the codebase:

- **Setup the Game Table component/page:** Create a new React component for the in-game table UI. If using Next.js routing, add a new page under app/game/\[tableId\]/play/page.tsx (or similar) that renders this component when the game starts. Alternatively, modify the existing prepare page to conditionally render the table UI after game start - but a separate route is cleaner.
- **Table HTML & CSS:** In this component, add the container and table surface &lt;div&gt; as described. Write a corresponding CSS Module (e.g., GameTable.module.css) for styles. Define styles for .table-container (with perspective) and .table-surface (size, background, rounded corners, 3D transform). Test that the table appears centered and scaled correctly on screen.
- **Integrate player data:** Fetch or receive the list of players and their info. In context, after the host clicks "开始对局" (Start Game), the server will broadcast a new state - likely containing seated players and a status (perhaps status: 'playing'). We should use the players array from that state. For now, we might mock some player data to test layout. Each player object has at least an id, nickname, and avatar filename[\[7\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L184-L192), which is enough for rendering PlayerAvatar (it expects playerName and avatarUrl). Construct the avatar URL (e.g., /avatars/\${player.avatar} if that's how images are served, as seen in prepare page[\[12\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L522-L530)).
- **Render avatars (PlayerAvatar components):** Map through the players array and output a &lt;PlayerAvatar&gt; for each. Provide the props: playerName={player.nickname}, avatarUrl={...}, and perhaps a consistent status (if needed, or leave it blank if not applicable during the game). Use the size prop if you want to adjust avatar size. Also, assign each an additional className or style for positioning. For instance, we might assign a generated class like .seat-0, .seat-1, etc., or we calculate inline styles with the left/top coordinates for each. If using a Seat component, do the positioning calculation inside it and apply via a styled div wrapping the PlayerAvatar.
- **Render card areas:** For each player, also render a container for their cards. If using a Seat component, inside it below the avatar you would place something like:  

- &lt;div className="card-area"&gt;  
    {player.cards && &lt;CardRow cards={player.cards} size="md" overlap="60%" angle={0} /&gt;}  
    &lt;/div&gt;
- For initial development, you might not have actual card data until the game logic is in place - you could use placeholder card backs or just leave it empty. But structuring it now allows you to easily fill in when the game deals cards. Ensure this card-area div is absolutely positioned (via the Seat container or its own style) at the computed inner radius position relative to center.
- **Absolute positioning logic:** Implement the function or effect to compute seat positions. If not using CSS for it, do something like: on component mount (and on resize events), determine the pixel size of the table container (you can get a ref to .table-container and read offsetWidth/offsetHeight). Then compute positions as outlined (angle, sin/cos). Update state or directly set style on each avatar/card element. One convenient pattern: use inline styles via React state, e.g., maintain an array of style objects for seats: seatStyles\[i\] = { left: X, top: Y } for avatars, and similarly for card areas (could even combine if each Seat has one absolute wrapper at center and you offset children inside - but simpler is separate absolute elements). On resize, recalc and update these styles.
- **Responsive adjustments:** Verify that when you resize the browser, the table scales (CSS should handle that) and the avatars/card areas move (our effect should handle that). If something isn't updating, ensure the resize listener is working or consider using window.onresize = ... or a hook from a library. Fine-tune any constants (e.g., perspective depth, radii percentages) after seeing the visual result.
- **Z-index layering:** Add CSS to ensure .table-surface is behind. For example: .table-surface { position: relative; z-index: 1; } .player-avatar, .card-area { position: absolute; z-index: 2; }. This way all avatars and cards (z=2) appear above the table (z=1). If community cards are to appear on the table, you might give them z-index 1 or 2 as well - but since they'll be placed at center, they likely won't clash with avatars visually. We just want to avoid any avatar being hidden. If using DOM order where table is rendered first and avatars after, you might get away without explicit z-index, but setting it is safer.
- **Test with various player counts:** Simulate 3 players, 4 players, etc., by providing dummy player lists of those lengths to the component. Ensure the spacing looks even. With 3, you should see a triangle formation (e.g., one top, two bottom perhaps). With 5 or 6, they should nicely wrap around. Tweak the starting angle if needed (for aesthetic symmetry - e.g., with 4 players you might prefer they align to top/bottom/left/right perfectly; that could mean starting angle at 45° instead of 0°, etc.). Our math could incorporate an offset angle (say offsetDeg = -90° to start at top, or -90 + halfSpacing to center a player at top if we want one directly at top for odd numbers). This is mostly cosmetic preference.
- **Incorporate into game flow:** Once the layout is working, hook this up to real game data. After the "prepare" phase, when the game starts, navigate players to this new UI (or switch state to show it). Use the actual player list from the server's game start event. Also be ready to render updates like when community cards are dealt (update the center CardRow) or when a player's chips change (you might later add chip counts near avatars, etc.).
- **Maintain code style:** Use CSS Modules for new styling (e.g., GameTable.module.css). Perhaps follow the naming convention seen (e.g., styles.tableContainer, etc.). The PlayerAvatar and CardRow components already have their own internal styles for their content; our CSS mainly deals with positioning and overall layout. Keep inline styles minimal (only for dynamic positioning if needed), and put constants in CSS where possible.

By following this plan, we will have a **comprehensive poker table UI**: a 3D-perspective table element, dynamically positioned player avatars around the edges, each with their cards neatly in front of them, all scaling to different screen sizes. This aligns with the codebase's patterns (reusing components like PlayerAvatar and CardRow) and meets all the stated requirements. The end result will be a visually correct and responsive poker table ready for gameplay.

**Sources:** The implementation details were derived from analyzing the project's existing components and requirements. For example, the project's React/Next setup and CSS module usage are shown in the code[\[1\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L3-L7)[\[3\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx#L5-L12). We plan to reuse the PlayerAvatar component (supports custom size and className[\[4\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx#L16-L26)) and the CardRow component for displaying cards[\[5\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/cards/CardRow.stories.tsx#L240-L248). The dynamic players/seats data structure is already present in the state management[\[7\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L184-L192), which we will leverage for rendering avatars and cards. This ensures our solution integrates smoothly with the existing codebase.

[\[1\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L3-L7) [\[6\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L324-L332) [\[7\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L184-L192) [\[8\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L280-L288) [\[11\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L308-L314) [\[12\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx#L522-L530) page.tsx

[https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/\[tableId\]/prepare/page.tsx](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/app/game/%5BtableId%5D/prepare/page.tsx)

[\[2\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/cards/CardRow.stories.tsx#L2-L10) [\[5\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/cards/CardRow.stories.tsx#L240-L248) [\[9\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/cards/CardRow.stories.tsx#L2-L5) CardRow.stories.tsx

<https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/cards/CardRow.stories.tsx>

[\[3\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx#L5-L12) [\[4\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx#L16-L26) [\[10\]](https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx#L61-L65) PlayerAvatar.tsx

<https://github.com/zt1106/vibe-baodatui/blob/07090484e6caec3977bb35829e30d73451a01c88/apps/web/components/poker/PlayerAvatar.tsx>